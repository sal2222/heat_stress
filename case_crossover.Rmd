---
title: "case_crossover"
output:
  html_document:
    toc: true
    toc_float: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = "C:/Users/slewa/Projects/heat_stress")

library(tidyverse)
library(readxl)
library(lubridate)
library(viridis)
library(knitr)
library(kableExtra)
library(zoo)
library(purrr)
library(furrr)
library(table1)
library(furniture)
library(kableExtra)
library(visdat)
library(naniar)
library(modelr)
library(survival)
library(splines)
library(pspline)
library(dlnm)



```

Here we will prepare the code for case-crossover analysis of daily outcomes.  

**Outcome**: HSI case (1 or 0)    
  *Variations*:     
    Type: hospitalization; ambulatory; reportable events    
    Diagnosis code: heat stroke + heat exhaustion; any HSI    

**Exposure**: Daily Temperature/Heat Index    
  *Variations*:  
    Averaging: max; mean; min  
    Index: temperature, heat index, WBGT 
    
**Effect modifiers**  
  Age group  
  Sex  
  Race/Ethnicity  
  Branch of Service  
  Grade/Rank group  
  BMI upon entry  
  Home of record state (region)  
  
  
** Decision points**:

Type of spline - penalized /natural
Number of lag days
Degrees of freedom (exposure, lag): Approach to evaluating

    

## Case-crossover

## Distributed lag non-linear models (DLMN)

```{r dlnm, eval = FALSE}
# vignette("dlnmOverview")

# Construct crossbasis for index of heat (exposure)

cb_heat <- df %>% 
  dlnm::crossbasis(
  daily_index,         
  lag = 7,    
  argvar = list(fun = "ns", df = 2), #  functional form of the dose-response curve 
  arglag = list(fun = "ns", df = 4))   # functional form of the lags  



summary(cb_heat)


```


## DLNM Time series model
```{r time_series, eval = FALSE}


model_ts <- glm(daily_hsi ~   
                  cb_heat +    # lagged, nonlinear term for heat exposure
                  day_of_week + 
                  ns(date, df = 4 * number_years) +
                  age + sex + race + brance + grade + bmi + hor,   # same-day nonlinear term for secular trend
              family = "quasipoisson",   # distribution family
              data = df)

# Extract predictions 

predictions <- dlnm::crosspred(
    cb_heat, model_ts, 
    at = 60:125, 
    bylag = 0.2,  
    cen = 0,
    cumul = TRUE)


```



## DLNM Conditional logistic model 

```{r prep_code, eval = FALSE}




# 4a Model

survival::clogit(Case ~ dailyPM + ns(dailyTemp, df=3) + ns(dailyRH, df=4) + 
               strata(DayID), # each case day is a strata
               weights = dailyCVDin, #number of events in each day
               method = "efron", # the method tells the model how to deal with ties
               df) 

# 4b Model Summary 

summary(mod.clogit.lin)

# 4c Extract odds ratio 

# 4c.i Create coefficient matrix

coeff.mat <- summary(mod.clogit.lin)$coef

# 4c.ii Extract the coefficient and standard error 

coeff_pm <- coeff.mat[1,1]
se_pm <- coeff.mat[1,3]

# 4c.iii Exponentiate coefficient & CI
# since the conditional logistic model involves taking the log of the odds
# we can compute the odds ratio by exponentiating the coefficients 
# in R exp(a) is the same as 'e to the power of a'

beta.pm <- exp(coeff_pm)
lci     <- exp(coeff_pm - 1.96*se_pm)
uci     <- exp(coeff_pm + 1.96*se_pm)

# 4c.iv Present results 

OR_pm <- paste(round(beta.pm, 4)," (95%CI: ", round(lci,4), ", ", round(uci,4),")", sep="")
OR_pm

# 4d Compute Odds Ratio for 10-unit increase
# we might also be interested in how the odds vary 
# for larger increments of pm2.5 

# 4d.i compute beta and CI 

beta.pm.10 <- exp(10 * coeff_pm)
lci.10     <- exp(10 * (coeff_pm - 1.96*se_pm))
uci.10     <- exp(10 * (coeff_pm + 1.96*se_pm))

# 4c.iv Present results 

OR_pm.10 <- paste(round(beta.pm.10, 4)," (95%CI: ", round(lci.10,4), ", ", round(uci.10,4),")", sep="")
OR_pm.10


# 4d Plot model 
# 4d.i Predict odds and standard error

ptemp <- predict(mod.clogit.lin, type = "terms", se = TRUE)
ptemp <- as.data.frame(ptemp) 

colnames(ptemp) <- c("term.PM","termTemp.ns.3", "termRH.ns.3", "se.PM","seTemp.ns.3", "seRH.ns.3")
df.pred         <- df %>% bind_cols(ptemp)

# 4d.ii Compute confidence intervals 

df.pred <- df.pred %>%
           mutate(lci = term.PM - 1.96 * se.PM , 
                  uci = term.PM + 1.96 * se.PM )

# 4d.iii Exponentiate 
df.pred <- df.pred %>%
           mutate(termPM = exp(term.PM),
           lci = exp(lci), 
           uci = exp(uci) )

# 4d.iv Plot

ggplot(df.pred, aes(dailyPM)) + 
  geom_line(aes(y = termPM), color = "lightsalmon2", size = 1) +
  geom_line(aes(y = lci), color = "grey", linetype = "dashed") + 
  geom_line(aes(y = uci), color = "grey", linetype = "dashed") +  
  geom_rug(col = "gray60") +
  xlab(expression("Daily PM"[2.5]))+
  ylab("Odds of CVD admission")



###################################
#### Footnote: coxph vs clogit ####
###################################
# create the two models
mod.coxph <- coxph(Surv(TimetoEvent, Case) ~ dailyPM + 
                     ns(dailyTemp, 3) + ns(dailyRH, 3)+
                     strata(DayID), 
                   weights = dailyCVDin,
                   df)

mod.clogit <- clogit(Case ~ dailyPM + ns(dailyTemp, 3) + ns(dailyRH, 3) + strata(DayID), 
                     weights = dailyCVDin,
                     method = "efron",
                     df)
# compare their coefficients 
summary(mod.coxph)
summary(mod.clogit)

#############################################
#### Footnote: Plotting Natural Splines  ####
#############################################
# 1A Create the models

mod.ns.2 <- clogit(Case ~  ns(dailyPM, df = 2) + ns(dailyTemp, df=3) + ns(dailyRH, df=4) + 
                     strata(DayID), weights = dailyCVDin, method = "efron", df)  
mod.ns.3 <- clogit(Case ~  ns(dailyPM, df = 3) + ns(dailyTemp, df=3) + ns(dailyRH, df=4) + 
                     strata(DayID), weights = dailyCVDin, method = "efron", df) 
mod.ns.4 <- clogit(Case ~  ns(dailyPM, df = 4) + ns(dailyTemp, df=3) + ns(dailyRH, df=4) + 
                     strata(DayID), weights = dailyCVDin, method = "efron", df)  

# 1B create predictions for each model
df.pred <- df

ptemp <- predict(mod.ns.2, type = "terms")
ptemp <- as.data.frame(ptemp) 
colnames(ptemp) <- c(c("termPM.ns.2"), colnames(ptemp)[2:ncol(ptemp)])
df.pred <- df.pred %>% bind_cols(ptemp)

ptemp <- predict(mod.ns.3, type = "terms")
ptemp <- as.data.frame(ptemp) 
colnames(ptemp) <- c(c("termPM.ns.3"), colnames(ptemp)[2:ncol(ptemp)])
df.pred <- df.pred %>% bind_cols(ptemp)

ptemp <- predict(mod.ns.4, type = "terms")
ptemp <- as.data.frame(ptemp) 
colnames(ptemp) <- c(c("termPM.ns.4"), colnames(ptemp)[2:ncol(ptemp)])
df.pred <- df.pred %>% bind_cols(ptemp)

# 1C Plot 
pdf(paste0(output.folder, "NaturalSplines_for_PM.pdf"))
ggplot(df.pred, aes(dailyPM)) + 
  geom_line(aes(y = exp(termPM.ns.2)), color = "Lightsalmon", size = 1) +
  geom_line(aes(y = exp(termPM.ns.3)), color = "lightsalmon2", size = 1) +
  geom_line(aes(y = exp(termPM.ns.4)), color = "lightsalmon4", size = 1) +
  xlab("dailyPm")+
  ylab("Odds of CVD admission")
dev.off()


```

## Cox Proportional-Hazards Model
